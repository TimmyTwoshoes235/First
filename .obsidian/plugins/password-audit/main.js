/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PasswordAuditPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_PASSWORD_AUDIT = "password-audit-view";
var PasswordAuditPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.registerView(
      VIEW_TYPE_PASSWORD_AUDIT,
      (leaf) => new PasswordAuditView(leaf)
    );
    const ribbonIcon = this.addRibbonIcon(
      "lock",
      // Built-in lock icon
      "Password Audit",
      (evt) => {
        this.activateView();
      }
    );
    ribbonIcon.addClass("password-audit-ribbon-icon");
    this.addCommand({
      id: "open-audit-panel",
      name: "Open audit panel",
      callback: () => {
        this.activateView();
      }
    });
    console.log("Password Audit Plugin loaded.");
  }
  async activateView(callback) {
    var _a, _b;
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_PASSWORD_AUDIT);
    if (leaves.length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: VIEW_TYPE_PASSWORD_AUDIT,
        active: true
      }));
    }
    const view = (_b = this.app.workspace.getLeavesOfType(VIEW_TYPE_PASSWORD_AUDIT)[0]) == null ? void 0 : _b.view;
    if (callback && view)
      callback(view);
  }
  onunload() {
    console.log("Password Audit Plugin unloaded.");
  }
};
var PasswordAuditView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.container = null;
  }
  getViewType() {
    return VIEW_TYPE_PASSWORD_AUDIT;
  }
  getDisplayText() {
    return "Password audit";
  }
  // Specify the icon for the view
  getIcon() {
    return "lock";
  }
  async onOpen() {
    const container = this.container = this.contentEl;
    if (!container)
      return;
    container.empty();
    container.createEl("h2", { text: "Password audit" });
    container.createEl("p", {
      text: "\u26A0\uFE0F Warning: Do not store passwords in Obsidian. Use a dedicated password manager.",
      cls: "password-warning"
    });
    const inputDiv = container.createDiv({ cls: "password-input-container" });
    new import_obsidian.Setting(inputDiv).setName("Analyze a password").setDesc("Enter a password to check its strength and breaches.").addText((text) => {
      text.setPlaceholder("Enter password...").onChange(async (password) => {
        const strength = this.analyzeStrength(password);
        const breached = await this.checkPasswordBreach(password);
        this.displayAnalysis(strength, breached);
      });
    });
    const resultsDiv = container.createDiv({ cls: "password-results-container" });
    resultsDiv.createEl("p", { text: "Password analysis results will appear here." });
  }
  async onClose() {
    var _a;
    (_a = this.container) == null ? void 0 : _a.empty();
  }
  displayAnalysis(strength, breached) {
    var _a;
    const resultsDiv = (_a = this.container) == null ? void 0 : _a.querySelector(".password-results-container");
    if (!resultsDiv)
      return;
    resultsDiv.empty();
    resultsDiv.createEl("p", {
      text: `Strength: ${strength}`,
      cls: `strength-${strength.toLowerCase().split(" ")[0]}`
    });
    resultsDiv.createEl("p", {
      text: breached ? "\u26A0\uFE0F This password has been breached!" : "\u2705 This password is safe from breaches.",
      cls: breached ? "breach-warning" : "breach-safe"
    });
  }
  analyzeStrength(password) {
    if (password.length < 8)
      return "Weak (too short)";
    if (!/[A-Z]/.test(password))
      return "Weak (no uppercase letters)";
    if (!/[a-z]/.test(password))
      return "Weak (no lowercase letters)";
    if (!/\d/.test(password))
      return "Weak (no numbers)";
    if (!/[!@#$%^&*()]/.test(password))
      return "Medium (no special characters)";
    return "Strong";
  }
  async checkPasswordBreach(password) {
    try {
      const hash = await this.hashPassword(password);
      const prefix = hash.substring(0, 5);
      const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`);
      const text = await response.text();
      const breaches = text.split("\n");
      return breaches.some((line) => line.startsWith(hash.substring(5).toUpperCase()));
    } catch (error) {
      console.error("Error checking password breach:", error);
      new import_obsidian.Notice("Failed to check password breach. Please try again later.");
      return false;
    }
  }
  async hashPassword(password) {
    const msgUint8 = new TextEncoder().encode(password);
    const hashBuffer = await crypto.subtle.digest("SHA-1", msgUint8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
};


/* nosourcemap */